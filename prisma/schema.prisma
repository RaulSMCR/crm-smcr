// schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// --- ENUMS ---

enum Role {
  USER
  ADMIN
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum PostType {
  TEXT
  VIDEO
  AUDIO
}

enum PostStatus {
  PENDING
  PUBLISHED
  ARCHIVED
}

enum ProfessionalServiceStatus {
  ACTIVE
  PAUSED
  REMOVED
}

// --- MODELOS DE IDENTIDAD ---

model User {
  id           Int    @id @default(autoincrement())
  email        String @unique
  passwordHash String
  name         String
  role         Role   @default(USER)

  // Datos Personales
  phone     String?
  avatarUrl String?
  birthDate DateTime?
  gender    String?
  timeZone  String    @default("UTC") // Crucial para conversiones de hora

  // Relación 1:1 Opcional - Solo si decide ser profesional
  professionalProfile ProfessionalProfile?

  // Actividad como Cliente (Paciente)
  appointmentsAsClient Appointment[] @relation("ClientAppointments")

  // Auditoría
  approvedPosts Post[] @relation("PostApprover")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
}

model ProfessionalProfile {
  id Int @id @default(autoincrement())

  // Vinculación estricta al User
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Datos Públicos del Profesional
  title          String // Ej: "Psicólogo Clínico"
  slug           String  @unique // Para url amigable: /pro/juan-perez
  bio            String? @db.Text
  registrationId String? // Matrícula
  isApproved     Boolean @default(false)

  // Configuración
  paymentLinkBase    String?
  googleRefreshToken String? @db.Text

  // Relaciones de Negocio
  services ServicesOnProfessionals[]
  posts    Post[]

  // Agenda y Tiempo
  availability Availability[] // Su horario base semanal
  timeOffs     TimeOff[] // Sus excepciones (vacaciones, bloqueos)

  // Actividad como Proveedor (Doctor)
  appointmentsAsProvider Appointment[] @relation("ProviderAppointments")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([isApproved])
  @@index([slug])
}

// --- MODELOS DE GESTIÓN DE TIEMPO ---

model Availability {
  id                    Int                 @id @default(autoincrement())
  professionalProfileId Int
  profile               ProfessionalProfile @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)

  dayOfWeek DayOfWeek

  // Usamos DateTime pero solo nos importará la HORA (Ej: 1970-01-01 09:00:00)
  startTime DateTime
  endTime   DateTime

  // Opcional: Pausa automática (Ej: 13:00 a 14:00)
  breakStart DateTime?
  breakEnd   DateTime?

  @@index([professionalProfileId])
}

model TimeOff {
  id                    Int                 @id @default(autoincrement())
  professionalProfileId Int
  profile               ProfessionalProfile @relation(fields: [professionalProfileId], references: [id], onDelete: Cascade)

  // Bloqueo específico (Ej: 2024-12-25 00:00 a 2024-12-25 23:59)
  startDate DateTime
  endDate   DateTime
  reason    String?

  @@index([professionalProfileId])
  @@index([startDate, endDate])
}

// --- MODELOS DE NEGOCIO ---

model Category {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  slug        String  @unique
  description String? @db.Text
  imageUrl    String?

  services Service[]
}

model Service {
  id          Int    @id @default(autoincrement())
  title       String
  slug        String @unique
  description String @db.Text

  // Duración Base (Puede ser sobreescrita por el profesional si la lógica lo permite, 
  // pero generalmente el servicio define el bloque de tiempo)
  durationMin Int @default(60)

  // Precio Base (Referencia)
  priceBase Decimal @db.Decimal(10, 2)

  categoryId Int?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  professionals ServicesOnProfessionals[]
  appointments  Appointment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ServicesOnProfessionals {
  id Int @id @default(autoincrement())

  professionalId Int
  profile        ProfessionalProfile @relation(fields: [professionalId], references: [id], onDelete: Cascade)

  serviceId Int
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  // Personalización del profesional para este servicio
  price            Decimal?                  @db.Decimal(10, 2) // Si es null, usa el precio base del servicio
  durationOverride Int? // Si quiere tardar más o menos que el estándar
  status           ProfessionalServiceStatus @default(ACTIVE)

  appointments Appointment[]

  createdAt DateTime @default(now())

  @@unique([professionalId, serviceId])
}

model Appointment {
  id Int @id @default(autoincrement())

  startTime DateTime
  endTime   DateTime // Calculado: startTime + serviceDuration

  status AppointmentStatus @default(PENDING)

  priceFinal Decimal @db.Decimal(10, 2) // Precio congelado al momento de la reserva

  // Relaciones
  clientId Int
  client   User @relation("ClientAppointments", fields: [clientId], references: [id])

  providerId Int
  provider   ProfessionalProfile @relation("ProviderAppointments", fields: [providerId], references: [id])

  serviceId Int
  service   Service @relation(fields: [serviceId], references: [id])

  // Opcional: link al registro específico de la relación pro-servicio
  professionalServiceId Int?
  professionalService   ServicesOnProfessionals? @relation(fields: [professionalServiceId], references: [id])

  // Datos externos
  googleEventId String? @unique
  cancelReason  String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([providerId, startTime])
  @@index([clientId])
  @@index([status])
}

model Post {
  id       Int     @id @default(autoincrement())
  slug     String  @unique
  title    String
  content  String  @db.Text
  imageUrl String?
  mediaUrl String?

  postType PostType   @default(TEXT)
  status   PostStatus @default(PENDING)

  authorId Int
  author   ProfessionalProfile @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Moderación
  approvedByUserId Int?
  approvedByUser   User? @relation("PostApprover", fields: [approvedByUserId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
}
